---
const { configData } = Astro.props;

function parseConfigProperties(configData: any): PropertyMeta[] {
  const properties: PropertyMeta[] = [];

  if (configData.value) {
    Object.entries(configData.value).forEach(([key, value]) => {
      // Skip the _component key as it's metadata
      if (key === "_component") {
        return;
      }
      const inputConfig = configData._inputs?.[key];

      properties.push({
        name: key,
        type: getPropertyType(inputConfig),
        optional: false,
        default: formatDefaultValue(value, inputConfig),
        enumValues: getEnumValues(inputConfig),
        description: inputConfig?.comment || "",
        nestedProperties: getNestedProperties(inputConfig, configData),
        arrayItemProperties: getArrayItemProperties(inputConfig, configData),
      });
    });
  }

  return properties;
}

function getPropertyType(inputConfig: any): string {
  if (!inputConfig) {
    return "string";
  }

  switch (inputConfig.type) {
    case "text":
    case "url":
      return "string";
    case "checkbox":
    case "switch":
      return "boolean";
    case "select":
      return "enum";
    case "number":
      return "number";
    case "array":
      return "array";
    case "object":
      return "object";
    default:
      return "string";
  }
}

function formatDefaultValue(value: any, inputConfig: any): string {
  if (value === undefined || value === null) {
    return "";
  }

  // Handle object types
  if (inputConfig?.type === "object" || (typeof value === "object" && !Array.isArray(value))) {
    return "object";
  }

  // Handle arrays
  if (Array.isArray(value)) {
    return "array";
  }

  // Handle booleans
  if (typeof value === "boolean") {
    return value.toString();
  }

  // Handle other types
  return String(value);
}

function getEnumValues(inputConfig: any): string[] | undefined {
  if (inputConfig?.type === "select" && inputConfig.options?.values) {
    if (Array.isArray(inputConfig.options.values)) {
      if (
        inputConfig.options.values.length > 0 &&
        typeof inputConfig.options.values[0] === "object" &&
        inputConfig.options.values[0].hasOwnProperty("id")
      ) {
        return inputConfig.options.values.map((item: any) => item.id);
      }
      if (
        inputConfig.options.values.length > 0 &&
        typeof inputConfig.options.values[0] === "object" &&
        inputConfig.options.values[0].hasOwnProperty("value")
      ) {
        return inputConfig.options.values.map((item: any) => item.value);
      }
      // Handle simple string values
      return inputConfig.options.values;
    }
  }
  return undefined;
}

function getNestedProperties(inputConfig: any, configData?: any): PropertyMeta[] | undefined {
  if (inputConfig?.type === "object" && inputConfig._inputs) {
    const nestedProperties: PropertyMeta[] = [];

    Object.entries(inputConfig._inputs).forEach(([key, nestedInput]: [string, any]) => {
      nestedProperties.push({
        name: key,
        type: getPropertyType(nestedInput),
        optional: false,
        default: formatDefaultValue(nestedInput.default, nestedInput),
        enumValues: getEnumValues(nestedInput),
        description: nestedInput?.comment || "",
        nestedProperties: getNestedProperties(nestedInput, configData),
        arrayItemProperties: getArrayItemProperties(nestedInput, configData),
      });
    });

    return nestedProperties;
  }

  return undefined;
}

function getArrayItemProperties(inputConfig: any, configData: any): PropertyMeta[] | undefined {
  // Check if this is an array with a structure reference
  if (inputConfig?.type === "array" && inputConfig.options?.structures) {
    const structures = inputConfig.options.structures;

    // Handle _structures.item format - when structures is a string reference
    if (typeof structures === "string" && structures.startsWith("_structures.")) {
      const structureName = structures.replace("_structures.", "");
      const structure = configData._structures?.[structureName];

      if (structure?.values && structure.values.length > 0) {
        // Get the first value as the template
        const itemTemplate = structure.values[0];
        const itemValue = itemTemplate.value;
        const itemInputs = itemTemplate._inputs;

        if (itemValue && itemInputs) {
          const arrayItemProperties: PropertyMeta[] = [];

          Object.entries(itemValue).forEach(([key, value]) => {
            const itemInputConfig = itemInputs[key];

            arrayItemProperties.push({
              name: key,
              type: getPropertyType(itemInputConfig),
              optional: false,
              default: formatDefaultValue(value, itemInputConfig),
              enumValues: getEnumValues(itemInputConfig),
              description: itemInputConfig?.comment || "",
              nestedProperties: getNestedProperties(itemInputConfig, configData),
              arrayItemProperties: getArrayItemProperties(itemInputConfig, configData),
            });
          });

          return arrayItemProperties;
        }
      }
    }
    // Handle array of structure definitions
    else if (Array.isArray(structures) && structures.length > 0) {
      // Get the first structure definition as the template
      const itemTemplate = structures[0];
      const itemValue = itemTemplate.value;
      const itemInputs = itemTemplate._inputs;

      if (itemValue && itemInputs) {
        const arrayItemProperties: PropertyMeta[] = [];

        Object.entries(itemValue).forEach(([key, value]) => {
          const itemInputConfig = itemInputs[key];

          arrayItemProperties.push({
            name: key,
            type: getPropertyType(itemInputConfig),
            optional: false,
            default: formatDefaultValue(value, itemInputConfig),
            enumValues: getEnumValues(itemInputConfig),
            description: itemInputConfig?.comment || "",
            nestedProperties: getNestedProperties(itemInputConfig, configData),
            arrayItemProperties: getArrayItemProperties(itemInputConfig, configData),
          });
        });

        return arrayItemProperties;
      }
    }
  }

  return undefined;
}

type PropertyMeta = {
  name: string;
  type: string;
  optional: boolean;
  default: unknown;
  enumValues?: string[];
  description: string;
  nestedProperties?: PropertyMeta[];
  arrayItemProperties?: PropertyMeta[];
};

const properties: PropertyMeta[] = configData ? parseConfigProperties(configData) : [];
---

<div class="properties">
  {
    properties.length > 0 ? (
      properties.map((prop: PropertyMeta) => {
        function renderProperty(prop: PropertyMeta) {
          return (
            <div class="property">
              <h3>
                <span class="property-name">{prop.name}</span>
                <span class="property-type">
                  {prop.type}
                  {prop.default && prop.type !== "object" && ` | default: ${prop.default}`}
                </span>
              </h3>
              {prop.description && <p>{prop.description}</p>}

              {prop.enumValues && prop.enumValues.length > 0 && (
                <div class="enum-values">
                  <strong>Accepted values:</strong>
                  <ul>
                    {prop.enumValues.map((value: string) => (
                      <li>
                        <code>{value}</code>
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {prop.nestedProperties && prop.nestedProperties.length > 0 && (
                <div class="nested-properties">
                  <strong>Properties:</strong>
                  <div class="nested-property-list">
                    {prop.nestedProperties.map((nestedProp: PropertyMeta) =>
                      renderProperty(nestedProp)
                    )}
                  </div>
                </div>
              )}

              {prop.arrayItemProperties && prop.arrayItemProperties.length > 0 && (
                <div class="nested-properties">
                  <strong>Item Properties:</strong>
                  <div class="nested-property-list">
                    {prop.arrayItemProperties.map((itemProp: PropertyMeta) =>
                      renderProperty(itemProp)
                    )}
                  </div>
                </div>
              )}
            </div>
          );
        }

        return renderProperty(prop);
      })
    ) : (
      <p>No properties available. Make sure the component has a valid .config.yml file.</p>
    )
  }
</div>

<style>
  .properties {
    .property {
      border-top: 1px solid var(--color-border-subtle);
      padding-block: var(--spacing-md);

      h3 {
        font-family: var(--font-mono);
        font-size: var(--font-size-md);

        .property-name {
          font-weight: var(--font-weight-bold);
        }

        .property-type {
          font-family: var(--font-headings);
          font-size: var(--font-size-sm);
          font-weight: 400;
        }
      }

      .enum-values {
        strong {
          color: var(--text-subtle-textColor);
          display: block;
          font-size: var(--font-size-sm);
          letter-spacing: 0.05em;
          text-transform: uppercase;
        }

        ul {
          display: flex;
          flex-wrap: wrap;
          gap: var(--spacing-md);
          list-style: none;
          margin: 0;
          padding: 0;
        }

        li {
          code {
            background: var(--background-subtle-backgroundColor);
            font-size: var(--font-size-sm);
            padding: 0;
          }
        }
      }
    }
  }

  .nested-property-list {
    border: 1px solid var(--color-border-subtle);
    border-radius: var(--radius-xs);
    margin-top: var(--spacing-md);
    padding-inline: var(--spacing-md);

    .property:first-child {
      border-top: none;
    }
  }
</style>
