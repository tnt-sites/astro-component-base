---
import Icon from "@components/elements/icon/icon.astro";
import RenderBlock from "@components/utils/renderBlock.astro";

const { href, text, class: className, defaultOpen = false, navBlocks = [], ...rest } = Astro.props;

const htmlAttributes = Object.fromEntries(
  Object.entries(rest).filter(([key]) => key !== "_bookshop_name")
);

const hasChildren = Astro.slots.has("default") || navBlocks.length > 0;
const dropdownId = `dropdown-toggle-${crypto.randomUUID()}`;
const contentId = `dropdown-content-${crypto.randomUUID()}`;
const isCurrentPage = href === Astro?.url?.pathname;
---

<li class:list={["nav-item", className, hasChildren ? "has-children" : null]} {...htmlAttributes}>
  {
    hasChildren ? (
      <>
        <input
          type="checkbox"
          id={dropdownId}
          class="nav-item-toggle"
          aria-expanded={defaultOpen ? "true" : "false"}
          aria-controls={contentId}
          autocomplete="off"
          checked={defaultOpen}
        />
        <label
          for={dropdownId}
          class="nav-item-trigger"
          role="button"
          aria-controls={contentId}
          tabindex="0"
        >
          {text}
          <slot name="text" />
          <span class="nav-item-icon">
            <Icon name="chevron-right" size="none" aria-hidden="true" />
          </span>
        </label>
        <div
          id={contentId}
          class="nav-item-content"
          role="region"
          aria-label={`${text} submenu`}
          aria-hidden={!defaultOpen}
        >
          <slot />
          <RenderBlock contentBlocks={navBlocks} />
        </div>
      </>
    ) : (
      <a href={href} aria-current={isCurrentPage ? "page" : undefined}>
        {text}
        <slot name="text" />
      </a>
    )
  }
</li>

<script>
  function closeAllDropdownsInParent(navItem: Element) {
    const navRoot = navItem.closest(".nav-root");
    if (!navRoot) return;

    const currentNavItem = navItem as HTMLElement;
    const currentLevel = getNavItemLevel(currentNavItem);

    navRoot.querySelectorAll(".nav-item-toggle").forEach((toggle) => {
      if (
        toggle instanceof HTMLInputElement &&
        toggle !== navItem.querySelector(".nav-item-toggle")
      ) {
        const toggleNavItem = toggle.closest(".nav-item") as HTMLElement;
        if (toggleNavItem) {
          const toggleLevel = getNavItemLevel(toggleNavItem);
          if (toggleLevel === currentLevel) {
            toggle.checked = false;
            updateAriaStates(toggle, false);
          }
        }
      }
    });
  }

  function getNavItemLevel(navItem: HTMLElement): number {
    let level = 0;
    let current = navItem;

    while (current) {
      if (current.classList.contains("nav-item-content")) {
        level++;
      }
      current = current.parentElement as HTMLElement;
    }

    return level;
  }

  function updateAriaStates(toggle: HTMLInputElement, isExpanded: boolean) {
    const contentId = toggle.getAttribute("aria-controls");
    const content = document.getElementById(contentId || "");

    if (content) {
      const ariaHidden = (!isExpanded).toString();
      content.setAttribute("aria-hidden", ariaHidden);
    }
  }

  function setupDropdowns() {
    document.querySelectorAll(".nav-item-toggle").forEach((toggle) => {
      toggle.addEventListener("change", (e) => {
        const target = e.target as HTMLInputElement;
        if (!target) return;

        const navItem = target.closest(".nav-item");
        if (!navItem) return;

        if (target.checked) {
          closeAllDropdownsInParent(navItem);
        }
        updateAriaStates(target, target.checked);
      });
    });

    // Add keyboard support for labels
    document.querySelectorAll(".nav-item-trigger").forEach((trigger) => {
      // Prevent multiple event listeners
      if (trigger.hasAttribute("data-keyboard-listener")) return;
      trigger.setAttribute("data-keyboard-listener", "true");

      trigger.addEventListener("keydown", (e) => {
        const keyEvent = e as KeyboardEvent;
        if (keyEvent.key === "Enter" || keyEvent.key === " ") {
          e.preventDefault();
          const checkboxId = trigger.getAttribute("for");
          const checkbox = document.getElementById(checkboxId || "") as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = !checkbox.checked;

            // Handle the dropdown logic directly instead of dispatching events
            const navItem = checkbox.closest(".nav-item");
            if (navItem) {
              if (checkbox.checked) {
                closeAllDropdownsInParent(navItem);
              }
              updateAriaStates(checkbox, checkbox.checked);
            }
          }
        }
      });
    });
  }

  function initializeAriaStates() {
    document.querySelectorAll(".nav-item-toggle").forEach((toggle) => {
      if (toggle instanceof HTMLInputElement) {
        updateAriaStates(toggle, toggle.checked);
      }
    });
  }

  function setupNavItemInitialization() {
    document.querySelectorAll(".nav-item").forEach((navItem) => {
      const navRoot = navItem.closest(".nav-root");
      if (navRoot && !navRoot.hasAttribute("data-nav-item-listener-setup")) {
        // Initialize nav-item functionality
        function initializeNavItem() {
          setupDropdowns();
          initializeAriaStates();
        }

        if (navRoot.hasAttribute("data-nav-initialized")) {
          initializeNavItem();
        } else {
          navRoot.addEventListener("nav-init", initializeNavItem);
        }
        navRoot.setAttribute("data-nav-item-listener-setup", "true");
      }
    });
  }

  // Ensure DOM is ready before setting up
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupNavItemInitialization);
  } else {
    setupNavItemInitialization();
  }
</script>
