---
import Button from "@core-elements/button/Button.astro";
import CarouselSlide from "./CarouselSlide.astro";

const {
  slides = [],
  autoPlay = false,
  autoScroll = false,
  slideWidthPercent = 100,
  minSlideWidth = 0,
  style = "",
  label,
  "data-prop": customDataProp = "slides",
  editable = true,
  _component,
  ...htmlAttributes
} = Astro.props;

const slugifyLabel = (label: string) => {
  return label
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
};

if (!htmlAttributes.id && label) {
  htmlAttributes.id = slugifyLabel(label);
}

const dataAttributes: Record<string, string> = {};

// These are hardcoded variables that you could setup
// to be configured to be set by the editor.

// Shows the indicators dots.
dataAttributes["data-show-indicators"] = "true";

// Shows the navigational arrows.
dataAttributes["data-show-arrows"] = "true";

// If false, the carousel will stop at the last slide.
dataAttributes["data-loop"] = "true";

// Positions the slides in the viewport.
dataAttributes["data-align"] = "center";

// Allows the carousel to scroll a specific number of
// slides at a time.
dataAttributes["data-slides-to-scroll"] = "auto";

if (autoPlay) {
  dataAttributes["data-autoplay"] = "3";
}

if (autoScroll) {
  dataAttributes["data-autoscroll"] = "1";
  dataAttributes["data-show-indicators"] = "false";
  dataAttributes["data-show-arrows"] = "false";
}

const carouselClasses = "carousel";

// Build the style attribute, merging custom styles with CSS variables
const carouselStyles = `
  --slide-width: ${slideWidthPercent}%;
  --min-slide-width: ${minSlideWidth}px;
  ${style}
`.trim();
---

<section
  class:list={carouselClasses}
  role="region"
  aria-label="Carousel"
  style={carouselStyles}
  {...htmlAttributes}
  {...dataAttributes}
>
  <div class="viewport">
    <div
      class="track"
      {...editable
        ? {
            "data-editable": "array",
            "data-component-key": "_component",
            "data-id-key": "_component",
            "data-prop": customDataProp,
          }
        : {}}
    >
      {
        slides.length > 0 ? (
          slides.map((slide: any, index: number) => (
            <editable-array-item data-component="building-blocks/wrappers/carousel/carousel-slide">
              <CarouselSlide
                contentSections={slide.contentSections}
                aria-label={`Slide ${index + 1} of ${slides.length}`}
              />
            </editable-array-item>
          ))
        ) : (
          <slot />
        )
      }
    </div>
  </div>

  <div class="controls-wrapper">
    <Button
      iconName="arrow-left"
      size="md"
      variant="tertiary"
      hideText={true}
      aria-label="Previous slide"
      class="prev"
      element="button"
    />

    <div class="indicators"></div>

    <Button
      iconName="arrow-right"
      size="md"
      variant="tertiary"
      hideText={true}
      aria-label="Next slide"
      class="next"
      element="button"
    />
  </div>
</section>

<script>
  import EmblaCarousel from "embla-carousel";
  import AutoScroll from "embla-carousel-auto-scroll";
  import Autoplay from "embla-carousel-autoplay";

  function setupCarousels() {
    const carousels = document.querySelectorAll(".carousel");

    carousels.forEach((carousel) => {
      if (carousel.hasAttribute("data-embla-initialized")) {
        return;
      }

      const viewport = carousel.querySelector(".viewport") as HTMLElement;
      const track = viewport?.querySelector(".track");
      const slides = track?.querySelectorAll(".slide");
      const controlsWrapper = carousel.querySelector(".controls-wrapper");
      const indicatorsContainer = controlsWrapper?.querySelector(".indicators");

      if (!viewport || !track || !slides || !slides.length) {
        console.warn("Carousel: Missing required elements");
        return;
      }

      const loop = carousel.hasAttribute("data-loop");
      const slidesToScroll = carousel.hasAttribute("data-slides-to-scroll")
        ? Number(carousel.getAttribute("data-slides-to-scroll")) || "auto"
        : "auto";
      const align = carousel.getAttribute("data-align") || "start";

      const plugins = [];
      if (carousel.hasAttribute("data-autoplay")) {
        const autoplayInterval = Number(carousel.getAttribute("data-autoplay")) * 1000 || 3000;
        plugins.push(Autoplay({ delay: autoplayInterval, stopOnInteraction: false }));
      }

      let watchDrag = true;
      if (carousel.hasAttribute("data-autoscroll")) {
        const scrollValue = parseFloat(carousel.getAttribute("data-autoscroll") || "1");
        const speed = isNaN(scrollValue) ? 1 : scrollValue;
        plugins.push(AutoScroll({ speed }));
        watchDrag = false;
      }

      const embla = EmblaCarousel(
        viewport,
        {
          loop,
          slidesToScroll,
          align,
          watchDrag,
          duration: 20,
          startIndex: 0,
          skipSnaps: false,
          inViewThreshold: 0.7,
        },
        plugins
      );

      // Mark this carousel as initialized
      carousel.setAttribute("data-embla-initialized", "true");

      // Navigation
      const prevButton = carousel.querySelector(".prev") as HTMLButtonElement;
      const nextButton = carousel.querySelector(".next") as HTMLButtonElement;

      const updateButtons = () => {
        if (prevButton) prevButton.disabled = !embla.canScrollPrev();
        if (nextButton) nextButton.disabled = !embla.canScrollNext();
      };

      updateButtons();
      embla.on("select", updateButtons);
      if (prevButton) prevButton.addEventListener("click", () => embla.scrollPrev());
      if (nextButton) nextButton.addEventListener("click", () => embla.scrollNext());

      // Setup indicators
      if (indicatorsContainer) {
        const renderDots = () => {
          indicatorsContainer.innerHTML = "";
          embla.scrollSnapList().forEach((_, index) => {
            const dot = document.createElement("button");
            dot.className = "indicator";
            dot.setAttribute("type", "button");
            dot.setAttribute("aria-label", `Go to position ${index + 1}`);
            dot.setAttribute("data-selected", (index === embla.selectedScrollSnap()).toString());
            dot.setAttribute("aria-selected", (index === embla.selectedScrollSnap()).toString());
            dot.addEventListener("click", () => embla.scrollTo(index));
            indicatorsContainer.appendChild(dot);
          });
        };

        const updateSelectedDot = () => {
          indicatorsContainer.querySelectorAll(".indicator").forEach((dot, index) => {
            const isSelected = index === embla.selectedScrollSnap();
            dot.setAttribute("data-selected", isSelected.toString());
            dot.setAttribute("aria-selected", isSelected.toString());
          });
        };

        embla.on("select", updateSelectedDot);
        embla.on("reInit", renderDots);
        renderDots();
      }
    });
  }

  // Initialize carousels when the page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupCarousels);
  } else {
    setupCarousels();
  }
  document.addEventListener("astro:page-load", setupCarousels);
</script>

<style lang="pcss" is:global>
  @layer components {
    .carousel {
      margin-top: var(--spacing-lg);
      position: relative;
      width: 100%;
      --slide-width: 100%;
      --min-slide-width: 0px;

      > .viewport {
        overflow: hidden;
        position: relative;
        width: 100%;
      }

      > .viewport > .track {
        display: flex;
        flex-wrap: nowrap;

        > editable-array-item, > .slide {
          flex-shrink: 0;
          flex-basis: calc(max(var(--slide-width, 100%), var(--min-slide-width, 0px)));
        }

        > editable-array-item > .slide {
          width: 100%;
        }
      }

      > .controls-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-md);
        margin-top: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }

      > .controls-wrapper > .prev,
      > .controls-wrapper > .next {
        pointer-events: auto;
        border-radius: var(--radius-full);
        background-color: var(--color-bg);
        flex-shrink: 0;

        &:hover {
          background-color: var(--color-bg-surface);
        }
      }

      > .controls-wrapper > .indicators {
        display: flex;
        justify-content: center;
        gap: var(--spacing-sm);
      }

      > .controls-wrapper > .indicators > .indicator {
        border-radius: var(--radius-full);
        width: 8px;
        aspect-ratio: 1/1;
        padding: 0;
        min-width: 0;
        min-height: 0;
        transition:
          transform var(--animation-normal) ease,
          background-color var(--animation-normal) ease;
        border: none;
        cursor: pointer;

        &[data-selected="true"] {
          background-color: var(--color-brand-muted);
          transform: scale(1.2);
        }
      }

      &[data-show-indicators="false"] {
        > .controls-wrapper > .indicators {
          display: none;
        }
      }

      &[data-show-arrows="false"] {
        > .controls-wrapper > .prev,
        > .controls-wrapper > .next {
          display: none;
        }
      }
    }
  }
</style>
