---
import Component from "@components/utils/renderBlock.astro";

const {
  firstColumnContentSections = [],
  secondColumnContentSections = [],
  distributionMode = "half",
  verticalAlignment = "top",
  reverse = false,
  reverseOrderOnMobile = true,
  fixedWidth,
  minSplitWidth = 700,
  gap = "lg",
  class: className,
  label,
  _component,
  ...htmlAttributes
} = Astro.props;

const slugifyLabel = (label: string) => {
  return label
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
};

if (!htmlAttributes.id && label) {
  htmlAttributes.id = slugifyLabel(label);
}

// Get content blocks and prop names based on reverse setting
const firstSplitBlocks = reverse ? secondColumnContentSections : firstColumnContentSections;
const secondSplitBlocks = reverse ? firstColumnContentSections : secondColumnContentSections;
const firstPropName = reverse ? "secondColumnContentSections" : "firstColumnContentSections";
const secondPropName = reverse ? "firstColumnContentSections" : "secondColumnContentSections";

const getReversedDistributionMode = (mode: string) => {
  const reverseMap = {
    "third-two-thirds": "two-thirds-third",
    "two-thirds-third": "third-two-thirds",
    "quarter-three-quarters": "three-quarters-quarter",
    "three-quarters-quarter": "quarter-three-quarters",
    "fixed-flexible": "flexible-fixed",
    "flexible-fixed": "fixed-flexible",
    half: "half",
  };

  return reverseMap[mode as keyof typeof reverseMap] || mode;
};

const finalDistributionMode = reverse
  ? getReversedDistributionMode(distributionMode)
  : distributionMode;

const splitId = `split-${crypto.randomUUID()}`;
---

<section
  class:list={[
    "split",
    `align-${verticalAlignment}`,
    finalDistributionMode,
    className,
    `gap-${gap}`,
    { reversed: reverse },
  ]}
  data-split-id={splitId}
  style={fixedWidth ? `--split-fixed-width: ${fixedWidth}px;` : ""}
  {...htmlAttributes}
>
  <div class="pane first">
    {
      reverse ? (
        <slot name="second">
          {firstSplitBlocks && firstSplitBlocks.length > 0 && (
            <Component contentSections={firstSplitBlocks} propName={firstPropName} />
          )}
        </slot>
      ) : (
        <slot name="first">
          {firstSplitBlocks && firstSplitBlocks.length > 0 && (
            <Component contentSections={firstSplitBlocks} propName={firstPropName} />
          )}
        </slot>
      )
    }
  </div>
  <div class="pane second">
    {
      reverse ? (
        <slot name="first">
          {secondSplitBlocks && secondSplitBlocks.length > 0 && (
            <Component contentSections={secondSplitBlocks} propName={secondPropName} />
          )}
        </slot>
      ) : (
        <slot name="second">
          {secondSplitBlocks && secondSplitBlocks.length > 0 && (
            <Component contentSections={secondSplitBlocks} propName={secondPropName} />
          )}
        </slot>
      )
    }
  </div>
</section>

{
  minSplitWidth > 0 && (
    <style
      is:inline
      set:html={`
    @container (max-width: ${minSplitWidth}px) {
      .split[data-split-id="${splitId}"] {
        grid-template-columns: var(--split-columns-mobile);
      }
      ${
        reverseOrderOnMobile
          ? `
      .split.reversed[data-split-id="${splitId}"] .pane.first {
        order: 2;
      }
      .split.reversed[data-split-id="${splitId}"] .pane.second {
        order: 1;
      }
      `
          : ""
      }
    }
  `}
    />
  )
}

<style lang="pcss" is:global>
  @layer components {
    .split {
      --split-columns-mobile: 1fr;
      --split-columns-desktop: 1fr 1fr;
      --split-fixed-width: auto;

      display: grid;
      gap: var(--spacing-lg);
      grid-template-columns: var(--split-columns-desktop);
      margin-top: var(--spacing-lg);

      &.gap-xs {
        gap: var(--spacing-xs);
      }

      &.gap-sm {
        gap: var(--spacing-sm);
      }

      &.gap-md {
        gap: var(--spacing-md);
      }

      &.gap-lg {
        gap: var(--spacing-lg);
      }

      &.gap-xl {
        gap: var(--spacing-xl);
      }

      &.gap-2xl {
        gap: var(--spacing-2xl);
      }

      &.gap-3xl {
        gap: var(--spacing-3xl);
      }

      @media (--to-sm) {
        &.gap-xs {
          gap: var(--spacing-xs);
        }

        &.gap-sm {
          gap: var(--spacing-xs);
        }

        &.gap-md {
          gap: var(--spacing-sm);
        }

        &.gap-lg {
          gap: var(--spacing-md);
        }

        &.gap-xl {
          gap: var(--spacing-md);
        }

        &.gap-2xl {
          gap: var(--spacing-lg);
        }

        &.gap-3xl {
          gap: var(--spacing-xl);
        }
      }

      &.align-top {
        align-items: start;
      }

      &.align-center {
        align-items: center;
      }

      &.align-bottom {
        align-items: end;
      }

      &.align-stretch {
        align-items: stretch;

        > .pane > *:not(editable-array):only-child,
        > .pane > editable-array > editable-array-item:only-child > * {
          height: 100%;
        }
      }

      .pane {
        min-width: 0;
        overflow-wrap: break-word;
        word-wrap: break-word;
        container-type: inline-size;

        > editable-array > editable-array-item:first-child > *:first-child,
        > :not(editable-array):first-child {
          margin-top: 0 !important;
        }
      }
    }

    .split.half {
      --split-columns-desktop: 1fr 1fr;
    }

    .split.third-two-thirds {
      --split-columns-desktop: 1fr 2fr;
    }

    .split.two-thirds-third {
      --split-columns-desktop: 2fr 1fr;
    }

    .split.quarter-three-quarters {
      --split-columns-desktop: 1fr 3fr;
    }

    .split.three-quarters-quarter {
      --split-columns-desktop: 3fr 1fr;
    }

    .split.fixed-flexible {
      --split-columns-desktop: var(--split-fixed-width) 1fr;
    }

    .split.flexible-fixed {
      --split-columns-desktop: 1fr var(--split-fixed-width);
    }
  }
</style>
