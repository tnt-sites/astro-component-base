---
import Button from "@components/elements/button/button.astro";
import Component from "@components/utils/renderBlock.astro";

const {
  slides = [],
  autoPlay = false,
  autoScroll = false,
  slideWidthPercent = 100,
  minSlideWidth = 0,
  style = "",
  label,
  ...rest
} = Astro.props;

const htmlAttributes = Object.fromEntries(
  Object.entries(rest).filter(([key]) => key !== "_bookshop_name")
);

const slugifyLabel = (label: string) => {
  return label
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
};

if (!htmlAttributes.id && label) {
  htmlAttributes.id = slugifyLabel(label);
}

const dataAttributes: Record<string, string> = {};

// These are hardcoded variables that could be configured to be set
// by the editor.

// Shows the indicators dots.
dataAttributes["data-show-indicators"] = "true";

// Shows the navigational arrows.
dataAttributes["data-show-arrows"] = "true";

// If false, the carousel will stop at the last slide.
dataAttributes["data-loop"] = "true";

// Positions the slides in the viewport.
dataAttributes["data-align"] = "center";

// Allows the carousel to scroll a specific number of
// slides at a time.
dataAttributes["data-slides-to-scroll"] = "auto";

if (autoPlay) {
  dataAttributes["data-autoplay"] = "3";
}

if (autoScroll) {
  dataAttributes["data-autoscroll"] = "1";
  dataAttributes["data-show-indicators"] = "false";
  dataAttributes["data-show-arrows"] = "false";
}

const carouselClasses = "carousel";

// Build the style attribute, merging custom styles with CSS variables
const carouselStyles = `
  --slide-width: ${slideWidthPercent}%;
  --min-slide-width: ${minSlideWidth}px;
  ${style}
`.trim();
---

<section
  class:list={carouselClasses}
  role="region"
  aria-label="Carousel"
  style={carouselStyles}
  {...htmlAttributes}
  {...dataAttributes}
>
  <div class="viewport">
    <div class="track">
      {
        slides.length > 0 ? (
          slides.map((slide: any, index: number) => (
            <div class="slide" role="group" aria-label={`Slide ${index + 1} of ${slides.length}`}>
              <Component contentBlocks={slide.contentBlocks} />
            </div>
          ))
        ) : (
          <slot />
        )
      }
    </div>
  </div>

  <div class="controls">
    <Button
      iconName="arrow-left"
      size="lg"
      variant="tertiary"
      hideText={true}
      aria-label="Previous slide"
      class="prev"
      element="button"
    />

    <Button
      iconName="arrow-right"
      size="lg"
      variant="tertiary"
      hideText={true}
      aria-label="Next slide"
      class="next"
      element="button"
    />
  </div>

  <div class="indicators"></div>
</section>

<script>
  import EmblaCarousel from "embla-carousel";
  import AutoScroll from "embla-carousel-auto-scroll";
  import Autoplay from "embla-carousel-autoplay";

  export default function setupCarousels() {
    const carousels = document.querySelectorAll(".carousel");

    carousels.forEach((carousel) => {
      if (carousel.hasAttribute("data-embla-initialized")) {
        return;
      }

      const viewport = carousel.querySelector(".viewport") as HTMLElement;
      const track = viewport?.querySelector(".track") as HTMLElement;
      const slides = track?.querySelectorAll(".slide") as NodeListOf<HTMLElement>;
      const indicatorsContainer = carousel.querySelector(".indicators") as HTMLElement;

      if (!viewport || !track || !slides.length) {
        console.warn("Carousel: Missing required elements");
        return;
      }

      const loop = carousel.hasAttribute("data-loop");
      const slidesToScroll = carousel.hasAttribute("data-slides-to-scroll")
        ? Number(carousel.getAttribute("data-slides-to-scroll")) || "auto"
        : "auto";
      const align = (carousel.getAttribute("data-align") || "start") as "start" | "center" | "end";

      const plugins = [];
      if (carousel.hasAttribute("data-autoplay")) {
        const autoplayInterval = Number(carousel.getAttribute("data-autoplay")) * 1000 || 3000;
        plugins.push(Autoplay({ delay: autoplayInterval, stopOnInteraction: false }));
      }

      let watchDrag = true;
      if (carousel.hasAttribute("data-autoscroll")) {
        const scrollValue = parseFloat(carousel.getAttribute("data-autoscroll") || "1");
        const speed = isNaN(scrollValue) ? 1 : scrollValue;
        plugins.push(AutoScroll({ speed }));
        watchDrag = false;
      }

      const embla = EmblaCarousel(
        viewport,
        {
          loop,
          slidesToScroll,
          align,
          watchDrag,
          duration: 20,
          startIndex: 0,
          skipSnaps: false,
          inViewThreshold: 0.7,
        },
        plugins
      );

      // Mark this carousel as initialized
      carousel.setAttribute("data-embla-initialized", "true");

      // Navigation
      const prevButton = carousel.querySelector(".prev") as HTMLButtonElement;
      const nextButton = carousel.querySelector(".next") as HTMLButtonElement;

      const updateButtons = () => {
        if (prevButton) prevButton.disabled = !embla.canScrollPrev();
        if (nextButton) nextButton.disabled = !embla.canScrollNext();
      };

      updateButtons();
      embla.on("select", updateButtons);
      if (prevButton) prevButton.addEventListener("click", () => embla.scrollPrev());
      if (nextButton) nextButton.addEventListener("click", () => embla.scrollNext());

      // Setup indicators
      if (indicatorsContainer) {
        const renderDots = () => {
          indicatorsContainer.innerHTML = "";
          embla.scrollSnapList().forEach((_, index) => {
            const dot = document.createElement("button");
            dot.className = "indicator";
            dot.setAttribute("type", "button");
            dot.setAttribute("aria-label", `Go to position ${index + 1}`);
            dot.setAttribute("data-selected", (index === embla.selectedScrollSnap()).toString());
            dot.setAttribute("aria-selected", (index === embla.selectedScrollSnap()).toString());
            dot.addEventListener("click", () => embla.scrollTo(index));
            indicatorsContainer.appendChild(dot);
          });
        };

        const updateSelectedDot = () => {
          indicatorsContainer.querySelectorAll(".indicator").forEach((dot, index) => {
            const isSelected = index === embla.selectedScrollSnap();
            dot.setAttribute("data-selected", isSelected.toString());
            dot.setAttribute("aria-selected", isSelected.toString());
          });
        };

        embla.on("select", updateSelectedDot);
        embla.on("reInit", renderDots);
        renderDots();
      }
    });
  }

  // Initialize carousels when the page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupCarousels);
  } else {
    setupCarousels();
  }
  document.addEventListener("astro:page-load", setupCarousels);
</script>
